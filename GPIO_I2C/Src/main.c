/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "stm32f407xx.h"
#include <stdio.h>

#define I2C1_SCL			GPIO_PIN_NO_6
#define I2C1_SDA			GPIO_PIN_NO_7
#define I2C2_SCL			GPIO_PIN_NO_10
#define I2C2_SDA			GPIO_PIN_NO_11
#define SYSTICK_TIM_CLK   	16000000UL
#define I2C_7bit_addr 		1
#define SLAVE_ADDR  		0x68

// typedef struct 
// {
	
// };


/*
https://blog.csdn.net/xiaocaohuyang/article/details/90313636
https://blog.csdn.net/weixin_49576307/article/details/135855357?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-135855357-blog-90313636.235^v43^pc_blog_bottom_relevance_base9&spm=1001.2101.3001.4242.1&utm_relevant_index=3
https://blog.csdn.net/dengjin20104042056/article/details/109047959
*/
// void delay(void)
// {
// 	for(uint32_t i =0; i < 5000 ; i++);
// }
void delay(void)
{
	uint32_t *pSRVR = (uint32_t*)0xE000E014;
	uint32_t *pSCSR = (uint32_t*)0xE000E010;
	uint32_t temp;
    /* calculation of reload value */
    uint32_t count_value = (SYSTICK_TIM_CLK/200000)-1;// if 1 second, then tick_hz = 1, if 1 millisecond, then tick_hz = 1000

    //Clear the value of SVR
    *pSRVR &= ~(0x00FFFFFFFF);

	*pSCSR &= ~(0x00FFFFFFFF);

    //load the value in to SVR
    *pSRVR |= count_value;

    //do some settings
    *pSCSR |= ( 1 << 2);  //Indicates the clock source, processor clock source (HSI = 16MHz)

    // *pSCSR |= ( 1 << 1); //Enables SysTick exception request:

    //enable the systick
    *pSCSR |= ( 1 << 0); //enables the counter

	do
	{
		temp = *pSCSR;
	} while ((temp & (0x01) && (!(temp & (1<<16)))));
	/*
	
	SysTick Control and Status Register
	[16] COUNTFLAG : Returns 1 if timer counted to 0 since last time this was read. 
	
	*/
}

void GPIO_ButtonInit(void)
{
	GPIO_Handle_t GPIOBtn;//,GpioLed;

	//this is btn gpio configuration
	GPIOBtn.pGPIOx = GPIOA;
	GPIOBtn.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_0;
	GPIOBtn.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_IN;
	GPIOBtn.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_FAST;
	GPIOBtn.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;

	GPIO_Init(&GPIOBtn);
}

void i2c_scl_low(GPIO_Handle_t* I2CPins, uint8_t PinNum)
{
	GPIO_WriteToOutputPin(I2CPins->pGPIOx, PinNum , 0);
}

void i2c_scl_high(GPIO_Handle_t* I2CPins, uint8_t PinNum)
{
	GPIO_WriteToOutputPin(I2CPins->pGPIOx, PinNum , 1);
}

void i2c_sda_low(GPIO_Handle_t* I2CPins, uint8_t PinNum)
{
	GPIO_WriteToOutputPin(I2CPins->pGPIOx, PinNum , 0);
}

void i2c_sda_high(GPIO_Handle_t* I2CPins, uint8_t PinNum)
{
	GPIO_WriteToOutputPin(I2CPins->pGPIOx, PinNum , 1);
}

void i2c_sda_input(GPIO_Handle_t* I2CPins)
{
    I2CPins->GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_IN;
    I2CPins->GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_PP;
    I2CPins->GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;
	GPIO_Init(I2CPins);
}

void i2c_sda_output(GPIO_Handle_t* I2CPins)
{
    I2CPins->GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_OUT;
    I2CPins->GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_OD;
	I2CPins->GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PIN_PU;
	GPIO_Init(I2CPins);
}

void I2C_GPIOinits(GPIO_Handle_t* I2CPins)
{
    I2CPins->pGPIOx = GPIOB;
    I2CPins->GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_OUT;
    // I2CPins->GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_ALTFN;
    // I2CPins->GPIO_PinConfig.GPIO_PinAltFunMode = 4;
	
    I2CPins->GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_OD;
    I2CPins->GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PIN_PU;
    I2CPins->GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_FAST;


	// I2CPins->GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_PP;
	// I2CPins->GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;
    //scl
    I2CPins->GPIO_PinConfig.GPIO_PinNumber = I2C1_SCL;
    GPIO_Init(I2CPins);
	i2c_scl_high(I2CPins, I2C1_SCL);

    // //sda
    // I2CPins.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_9;
    // GPIO_Init(&I2CPins);


    // //scl
    // I2CPins.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_8;
    // GPIO_Init(&I2CPins);

    //sda
    I2CPins->GPIO_PinConfig.GPIO_PinNumber = I2C1_SDA;
    GPIO_Init(I2CPins);
	i2c_sda_high(I2CPins, I2C1_SDA);
}

void I2C_Slave_GPIOinits(GPIO_Handle_t* I2CPins)
{
    I2CPins->pGPIOx = GPIOB;
    I2CPins->GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_IN;
    // I2CPins->GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_ALTFN;
    // I2CPins->GPIO_PinConfig.GPIO_PinAltFunMode = 4;
	
    I2CPins->GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_PP;
    I2CPins->GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;
    I2CPins->GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_FAST;


	// I2CPins->GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_PP;
	// I2CPins->GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;
    //scl
    I2CPins->GPIO_PinConfig.GPIO_PinNumber = I2C2_SCL;
    GPIO_Init(I2CPins);

    //sda
    I2CPins->GPIO_PinConfig.GPIO_PinNumber = I2C2_SDA;
    GPIO_Init(I2CPins);
}

static uint8_t read_i2c_sda(GPIO_Handle_t* I2CPins, uint8_t PinNum)
{
	int temp;
	temp = GPIO_ReadFromInputPin(I2CPins->pGPIOx, PinNum);
	return temp;
}



static i2c_start(GPIO_Handle_t* I2CPins)
{
	i2c_sda_high(I2CPins, I2C1_SDA);
	delay();
	i2c_scl_high(I2CPins, I2C1_SCL);
	delay();
	i2c_sda_low(I2CPins, I2C1_SDA);
	delay();
	i2c_scl_low(I2CPins, I2C1_SCL);
	delay();
}

static i2c_stop(GPIO_Handle_t* I2CPins)
{
	i2c_scl_low(I2CPins, I2C1_SCL);
	delay();
	i2c_sda_low(I2CPins, I2C1_SDA);
	delay();
	i2c_scl_high(I2CPins, I2C1_SCL);
	delay();
	i2c_sda_high(I2CPins, I2C1_SDA);
	delay();
}

static void i2c_send_ack(GPIO_Handle_t* I2CPins)
{
	i2c_sda_low(I2CPins, I2C1_SDA);
	delay();
	i2c_scl_high(I2CPins, I2C1_SCL);
	delay();
	i2c_scl_low(I2CPins, I2C1_SCL);
	delay();
}

static void i2c_send_nack(GPIO_Handle_t* I2CPins)
{
	i2c_sda_high(I2CPins, I2C1_SDA);
	delay();
	i2c_scl_high(I2CPins, I2C1_SCL);
	delay();
	i2c_scl_low(I2CPins, I2C1_SCL);
	delay();
	i2c_sda_low(I2CPins, I2C1_SDA);
	delay();
}

static uint8_t i2c_wait_ack(GPIO_Handle_t* I2CPins, GPIO_Handle_t* I2CSlave, uint8_t *ack_flag)
{
	
	// *ack_flag |= 0xff;
	i2c_sda_output(I2CSlave);
	i2c_sda_input(I2CPins);
	if(*ack_flag)
	{
		i2c_sda_high(I2CSlave, I2C2_SDA);
	}
	else
	{
		i2c_sda_low(I2CSlave, I2C2_SDA);
	}
	delay();
	uint8_t wait_time;
	uint8_t ack_nack = 1;
	// while(read_i2c_sda(I2CPins,I2C1_SDA))
	// {
	// 	wait_time++;
	// 	if(wait_time >= 2000)
	// 	{
	// 		ack_nack = 0;
	// 		break;
	// 	}
	// }
	i2c_scl_high(I2CPins, I2C1_SCL);
	delay();
	i2c_scl_low(I2CPins, I2C1_SCL);
	delay();
	i2c_sda_low(I2CPins, I2C1_SDA);
	delay();
	i2c_sda_output(I2CPins);
	i2c_sda_input(I2CSlave);
	(*ack_flag) &= ~(0xff);
	return ack_nack;
}

static void i2c_write_byte(GPIO_Handle_t* I2CPins, uint8_t data, GPIO_Handle_t* I2CSlave, uint8_t *ack_flag)
{
	uint8_t i;
	for(i = 0; i < 8 ;i++)
	{
		i2c_scl_low(I2CPins, I2C1_SCL);

		if(data & 0x80)
		{
			i2c_sda_high(I2CPins, I2C1_SDA);
		}
		else
		{
			i2c_sda_low(I2CPins, I2C1_SDA);
		}
		delay();

		if(read_i2c_sda(I2CSlave, I2C2_SDA) != ((I2CPins->pGPIOx->ODR >>I2C1_SDA) & 0x1))	(*ack_flag) |= (1<<i);

		delay();

		i2c_scl_high(I2CPins, I2C1_SCL);
		delay();
		data <<= 1;
	}
	i2c_scl_low(I2CPins, I2C1_SCL);
	i2c_sda_low(I2CPins, I2C1_SDA);
	delay();
}

void i2c_write_Nbyte(GPIO_Handle_t* I2CPins, uint8_t data, uint8_t slaveAddr, GPIO_Handle_t* I2CSlave)
{
	uint8_t i;
#if I2C_7bit_addr
	data <<= 1;
	slaveAddr <<= 1;
#endif
	uint8_t ack_flag = 0x00;
	i2c_start(I2CPins);
	i2c_write_byte(I2CPins, slaveAddr, I2CSlave, &ack_flag);

	if(!i2c_wait_ack(I2CPins, I2CSlave, &ack_flag))
		goto _err;

	_err:
	i2c_stop(I2CPins);
	// return 0;
}

static void i2c_read_byte(GPIO_Handle_t* I2CPins)
{
	i2c_sda_input(I2CPins);
	uint8_t i;
	uint8_t data = (I2CPins, I2C1_SDA);
	for(i = 0; i< 8;i++)
	{
		i2c_scl_low(I2CPins, I2C1_SCL);
		if(data & 0x40)
		{
			i2c_sda_high(I2CPins, I2C1_SDA);
		}
		else
		{
			i2c_sda_low(I2CPins, I2C1_SDA);
		}
		delay();
		i2c_scl_high(I2CPins, I2C1_SCL);
		delay();
		data <<= 1;
	}
	i2c_scl_low(I2CPins, I2C1_SCL);
	delay();
	i2c_sda_output(I2CPins);
}

int main(void)
{
	GPIO_Handle_t I2C1Pins, I2C2Pins;
	memset(&I2C1Pins, 0 , sizeof(I2C1Pins));
	memset(&I2C2Pins, 0 , sizeof(I2C2Pins));

	I2C_GPIOinits(&I2C1Pins);
	I2C_Slave_GPIOinits(&I2C2Pins);

    GPIO_ButtonInit();
	while( ! GPIO_ReadFromInputPin(GPIOA,GPIO_PIN_NO_0) );
	delay();

	uint8_t commandcode = 0x51;
	i2c_write_Nbyte(&I2C1Pins, commandcode,  SLAVE_ADDR, &I2C2Pins);
	// printf("%d\n",I2C2Pins.pGPIOx->IDR);
	// printf("%d\n",I2C2Pins.pGPIOx->ODR);

	// i2c_start(&I2C1Pins);
	// delay();
	// // i2c_write_byte(&I2C1Pins, 0x68);
	// // delay();
	// // i2c_send_nack(&I2C1Pins);
	// delay();
	// i2c_stop(&I2C1Pins);

//     /* Loop forever */
// 	printf("test\n");
	//this is led gpio configuration
	return 0;
}
