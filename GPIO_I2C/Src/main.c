/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "stm32f407xx.h"
#include <stdio.h>

#define I2C1_SCL			GPIO_PIN_NO_6
#define I2C1_SDA			GPIO_PIN_NO_7
#define I2C2_SCL			GPIO_PIN_NO_10
#define I2C2_SDA			GPIO_PIN_NO_11
#define SYSTICK_TIM_CLK   	16000000UL
#define I2C_7bit_addr 		1
#define SLAVE_ADDR  		0x68
uint8_t rcv_buf[32];
uint8_t i2c1_read;
// typedef struct 
// {
	
// };


/*
https://blog.csdn.net/xiaocaohuyang/article/details/90313636
https://blog.csdn.net/weixin_49576307/article/details/135855357?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-135855357-blog-90313636.235^v43^pc_blog_bottom_relevance_base9&spm=1001.2101.3001.4242.1&utm_relevant_index=3
https://blog.csdn.net/dengjin20104042056/article/details/109047959
*/
// void delay(void)
// {
// 	for(uint32_t i =0; i < 5000 ; i++);
// }
void delay(void)
{
	uint32_t *pSRVR = (uint32_t*)0xE000E014;
	uint32_t *pSCSR = (uint32_t*)0xE000E010;
	uint32_t temp;
    /* calculation of reload value */
    uint32_t count_value = (SYSTICK_TIM_CLK/200000)-1;// if 1 second, then tick_hz = 1, if 1 millisecond, then tick_hz = 1000

    //Clear the value of SVR
    *pSRVR &= ~(0x00FFFFFFFF);

	*pSCSR &= ~(0x00FFFFFFFF);

    //load the value in to SVR
    *pSRVR |= count_value;

    //do some settings
    *pSCSR |= ( 1 << 2);  //Indicates the clock source, processor clock source (HSI = 16MHz)

    // *pSCSR |= ( 1 << 1); //Enables SysTick exception request:

    //enable the systick
    *pSCSR |= ( 1 << 0); //enables the counter

	do
	{
		temp = *pSCSR;
	} while ((temp & (0x01) && (!(temp & (1<<16)))));
	/*
	
	SysTick Control and Status Register
	[16] COUNTFLAG : Returns 1 if timer counted to 0 since last time this was read. 
	
	*/
}

void GPIO_ButtonInit(void)
{
	GPIO_Handle_t GPIOBtn;//,GpioLed;

	//this is btn gpio configuration
	GPIOBtn.pGPIOx = GPIOA;
	GPIOBtn.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_0;
	GPIOBtn.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_IN;
	GPIOBtn.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_FAST;
	GPIOBtn.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;

	GPIO_Init(&GPIOBtn);
}

void i2c_scl_low(GPIO_Handle_t* I2CPins, uint8_t PinNum)
{
	GPIO_WriteToOutputPin(I2CPins->pGPIOx, PinNum , 0);
}

void i2c_scl_high(GPIO_Handle_t* I2CPins, uint8_t PinNum)
{
	GPIO_WriteToOutputPin(I2CPins->pGPIOx, PinNum , 1);
}

void i2c_sda_low(GPIO_Handle_t* I2CPins, uint8_t PinNum)
{
	GPIO_WriteToOutputPin(I2CPins->pGPIOx, PinNum , 0);
}

void i2c_sda_high(GPIO_Handle_t* I2CPins, uint8_t PinNum)
{
	GPIO_WriteToOutputPin(I2CPins->pGPIOx, PinNum , 1);
}

void i2c_sda_input(GPIO_Handle_t* I2CPins)
{
    I2CPins->GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_IN;
    I2CPins->GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_PP;
    I2CPins->GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;
	GPIO_Init(I2CPins);
}

void i2c_sda_output(GPIO_Handle_t* I2CPins)
{
	int temp;
    I2CPins->GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_OUT;
    I2CPins->GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_OD;
	I2CPins->GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PIN_PU;
	GPIO_Init(I2CPins);
}

void I2C_GPIOinits(GPIO_Handle_t* I2CPins)
{
    I2CPins->pGPIOx = GPIOB;
    I2CPins->GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_OUT;
    // I2CPins->GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_ALTFN;
    // I2CPins->GPIO_PinConfig.GPIO_PinAltFunMode = 4;
	
    I2CPins->GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_OD;
    I2CPins->GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PIN_PU;
    I2CPins->GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_FAST;


	// I2CPins->GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_PP;
	// I2CPins->GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;
    //scl
    I2CPins->GPIO_PinConfig.GPIO_PinNumber = I2C1_SCL;
	I2CPins->scl = I2C1_SCL;
    GPIO_Init(I2CPins);
	i2c_scl_high(I2CPins, I2C1_SCL);

    // //sda
    // I2CPins.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_9;
    // GPIO_Init(&I2CPins);


    // //scl
    // I2CPins.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_8;
    // GPIO_Init(&I2CPins);

    //sda
    I2CPins->GPIO_PinConfig.GPIO_PinNumber = I2C1_SDA;
	I2CPins->sda = I2C1_SDA;
    GPIO_Init(I2CPins);
	i2c_sda_high(I2CPins, I2C1_SDA);
}

void I2C_Slave_GPIOinits(GPIO_Handle_t* I2CPins)
{
    I2CPins->pGPIOx = GPIOB;
    I2CPins->GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_IN;
    // I2CPins->GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_ALTFN;
    // I2CPins->GPIO_PinConfig.GPIO_PinAltFunMode = 4;
	
    I2CPins->GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_PP;
    I2CPins->GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;
    I2CPins->GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_FAST;


	// I2CPins->GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_PP;
	// I2CPins->GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;
    //scl
    I2CPins->GPIO_PinConfig.GPIO_PinNumber = I2C2_SCL;
	I2CPins->scl = I2C2_SCL;
    GPIO_Init(I2CPins);

    //sda
    I2CPins->GPIO_PinConfig.GPIO_PinNumber = I2C2_SDA;
	I2CPins->sda = I2C2_SDA;
    GPIO_Init(I2CPins);
}

static uint8_t read_i2c_sda(GPIO_Handle_t* I2CPins, uint8_t PinNum)
{
	int res;
	res = GPIO_ReadFromInputPin(I2CPins->pGPIOx, PinNum);
	return res;
}



static i2c_start(GPIO_Handle_t* I2CPins)
{
	i2c_sda_high(I2CPins, I2C1_SDA);
	delay();
	i2c_scl_high(I2CPins, I2C1_SCL);
	delay();
	i2c_sda_low(I2CPins, I2C1_SDA);
	delay();
	i2c_scl_low(I2CPins, I2C1_SCL);
	delay();
}

static i2c_stop(GPIO_Handle_t* I2CPins)
{
	i2c_scl_low(I2CPins, I2C1_SCL);
	delay();
	i2c_sda_low(I2CPins, I2C1_SDA);
	delay();
	i2c_scl_high(I2CPins, I2C1_SCL);
	delay();
	i2c_sda_high(I2CPins, I2C1_SDA);
	delay();
}

static void i2c_send_ack(GPIO_Handle_t* I2CPins)
{
	i2c_sda_low(I2CPins, I2C1_SDA);
	delay();
	i2c_scl_high(I2CPins, I2C1_SCL);
	delay();
	i2c_scl_low(I2CPins, I2C1_SCL);
	delay();
}

static void i2c_send_nack(GPIO_Handle_t* I2CPins)
{
	i2c_sda_high(I2CPins, I2C1_SDA);
	delay();
	i2c_scl_high(I2CPins, I2C1_SCL);
	delay();
	i2c_scl_low(I2CPins, I2C1_SCL);
	delay();
	i2c_sda_low(I2CPins, I2C1_SDA);
	delay();
}

static uint8_t i2c_wait_ack(GPIO_Handle_t* I2CPins, GPIO_Handle_t* I2CSlave, uint8_t *ack_flag)
{
	uint8_t ack_nack = 1;

	//Set output first because input is floating
	i2c_sda_output(I2CSlave);
	i2c_sda_input(I2CPins);
		
		
	if(*ack_flag)
	{
		i2c_sda_high(I2CSlave, I2CSlave->sda);
	}
	else
	{
		i2c_sda_low(I2CSlave, I2CSlave->sda);
	}
	delay();
	

	I2CPins->scl == I2C1_SCL ? i2c_scl_high(I2CPins, I2CPins->scl): i2c_scl_high(I2CSlave, I2CSlave->scl);
	delay();
	I2CPins->scl == I2C1_SCL ? i2c_scl_low(I2CPins, I2CPins->scl): i2c_scl_low(I2CSlave, I2CSlave->scl);
	delay();
	i2c_sda_low(I2CPins, I2CPins->sda);
	delay();

	//Set output first because input is floating
	i2c_sda_output(I2CPins);
	i2c_sda_input(I2CSlave);	
	
	(*ack_flag) &= ~(0xff);

	return ack_nack;
}

static void i2c_write_byte(GPIO_Handle_t* I2CPins, uint8_t data, GPIO_Handle_t* I2CSlave, uint8_t *ack_flag)
{
	uint8_t i;
	uint8_t last_flag = 0;
	if(data & 0x01) last_flag = 1;
	for(i = 0; i < 8 ;i++)
	{
		I2CPins->scl == I2C1_SCL ? i2c_scl_low(I2CPins, I2CPins->scl): i2c_scl_low(I2CSlave, I2CSlave->scl);
		
		if(data & 0x80)
		{
			
			i2c_sda_high(I2CPins, I2CPins->sda);
		}
		else
		{
			i2c_sda_low(I2CPins, I2CPins->sda);
		}
		delay();

		if(read_i2c_sda(I2CSlave, I2CSlave->sda) != ((I2CPins->pGPIOx->ODR >>I2CPins->sda) & 0x1))	(*ack_flag) |= (1<<i);

		delay();

		I2CPins->scl == I2C1_SCL ? i2c_scl_high(I2CPins, I2CPins->scl): i2c_scl_high(I2CSlave, I2CSlave->scl);
		delay();
		data <<= 1;
	}
	I2CPins->scl == I2C1_SCL ? i2c_scl_low(I2CPins, I2CPins->scl): i2c_scl_low(I2CSlave, I2CSlave->scl);
	if(last_flag == 0)
	{
		i2c_sda_low(I2CPins, I2CPins->sda);
		i2c_sda_low(I2CSlave, I2CSlave->sda);
	}	
	delay();
}

void i2c_write_Nbyte(GPIO_Handle_t* I2CPins, uint8_t data, uint8_t slave_addr, GPIO_Handle_t* I2CSlave)
{
	
	uint8_t i;
#if I2C_7bit_addr
	if(I2CPins->scl == I2C1_SCL)
	{
		slave_addr <<= 1;
		slave_addr &= ~(1);
	}	
#endif
	uint8_t ack_flag = 0x00;

	i2c_write_byte(I2CPins, slave_addr, I2CSlave, &ack_flag);

	if(!i2c_wait_ack(I2CPins, I2CSlave, &ack_flag))
		goto _err;
	
	i2c_sda_high(I2CPins, I2CPins->sda);
	delay();

	i2c_write_byte(I2CPins, data, I2CSlave, &ack_flag);

	if(!i2c_wait_ack(I2CPins, I2CSlave, &ack_flag))
		goto _err;


	i2c_sda_high(I2CPins, I2CPins->sda);
	delay();


	_err:
	return;
}

static void i2c_read_byte(GPIO_Handle_t* I2CPins, uint8_t data, GPIO_Handle_t* I2CSlave)
{
	i2c_sda_input(I2CPins);
	uint8_t i;
	data = I2CSlave->pGPIOx->ODR;
	for(i = 0; i< 8;i++)
	{
		i2c_scl_low(I2CPins, I2C1_SCL);
		if(data & 0x80)
		{
			i2c_sda_high(I2CPins, I2C1_SDA);
		}
		else
		{
			i2c_sda_low(I2CPins, I2C1_SDA);
		}
		delay();
		i2c_scl_high(I2CPins, I2C1_SCL);
		delay();
		data <<= 1;
	}
	i2c_scl_low(I2CPins, I2C1_SCL);
	delay();
}

void i2c_read_Nbyte(GPIO_Handle_t* I2CPins, uint8_t* data, uint8_t slave_addr, GPIO_Handle_t* I2CSlave, int len)
{
	uint8_t i;
#if I2C_7bit_addr
	if(I2CPins->scl == I2C1_SCL)
	{
		slave_addr <<= 1;
		slave_addr |= 1;
	}	
#endif
	uint8_t some_data[] = "slave send\n";

	uint8_t ack_flag = 0x00;


	i2c_write_byte(I2CPins, slave_addr, I2CSlave, &ack_flag);

	if(!i2c_wait_ack(I2CPins, I2CSlave, &ack_flag))
		goto _err;

	i2c_sda_high(I2CPins, I2CPins->sda);
	delay();

	//Set output first because input is floating
	i2c_sda_output(I2CSlave);
	i2c_sda_input(I2CPins);

	for(i = 0; i< len; i++)
	{
		i2c_write_byte(I2CSlave, data[i], I2CPins, &ack_flag);
		if(i == len-1)
		{
			//Set output first because input is floating
			i2c_sda_output(I2CPins);
			i2c_sda_input(I2CSlave);
			i2c_send_nack(I2CPins);
		}
		else
		{
			if(!i2c_wait_ack(I2CSlave, I2CPins, &ack_flag))
			{
				goto _err;
			}
				
		}
	}

	_err:
	return;
}



int main(void)
{
	uint8_t some_data[] = "slave send\n";
	GPIO_Handle_t I2C1Pins, I2C2Pins;
	memset(&I2C1Pins, 0 , sizeof(I2C1Pins));
	memset(&I2C2Pins, 0 , sizeof(I2C2Pins));

	I2C_GPIOinits(&I2C1Pins);
	I2C_Slave_GPIOinits(&I2C2Pins);

    GPIO_ButtonInit();
	while( ! GPIO_ReadFromInputPin(GPIOA,GPIO_PIN_NO_0) );
	delay();

	i2c_start(&I2C1Pins);
	i2c_write_Nbyte(&I2C1Pins, 0x51, SLAVE_ADDR, &I2C2Pins);
	i2c_stop(&I2C1Pins);

	int len = 11;
	i2c_start(&I2C1Pins);
	i2c_read_Nbyte(&I2C1Pins, &len, SLAVE_ADDR, &I2C2Pins, 1);
	i2c_stop(&I2C1Pins);

	i2c_start(&I2C1Pins);
	i2c_write_Nbyte(&I2C1Pins, 0x52, SLAVE_ADDR, &I2C2Pins);
	i2c_stop(&I2C1Pins);
	
	i2c_start(&I2C1Pins);
	i2c_read_Nbyte(&I2C1Pins, some_data, SLAVE_ADDR, &I2C2Pins, 11);
	i2c_stop(&I2C1Pins);

	return 0;
}
